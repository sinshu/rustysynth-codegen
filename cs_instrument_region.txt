int SampleStart => sample.Start + StartAddressOffset;
int SampleEnd => sample.End + EndAddressOffset;
int SampleStartLoop => sample.StartLoop + StartLoopAddressOffset;
int SampleEndLoop => sample.EndLoop + EndLoopAddressOffset;
int StartAddressOffset => 32768 * this[GeneratorType.StartAddressCoarseOffset] + this[GeneratorType.StartAddressOffset];
int EndAddressOffset => 32768 * this[GeneratorType.EndAddressCoarseOffset] + this[GeneratorType.EndAddressOffset];
int StartLoopAddressOffset => 32768 * this[GeneratorType.StartLoopAddressCoarseOffset] + this[GeneratorType.StartLoopAddressOffset];
int EndLoopAddressOffset => 32768 * this[GeneratorType.EndLoopAddressCoarseOffset] + this[GeneratorType.EndLoopAddressOffset];
int ModulationLfoToPitch => this[GeneratorType.ModulationLfoToPitch];
int VibratoLfoToPitch => this[GeneratorType.VibratoLfoToPitch];
int ModulationEnvelopeToPitch => this[GeneratorType.ModulationEnvelopeToPitch];
float InitialFilterCutoffFrequency => SoundFontMath.CentsToHertz(this[GeneratorType.InitialFilterCutoffFrequency]);
float InitialFilterQ => 0.1F * this[GeneratorType.InitialFilterQ];
int ModulationLfoToFilterCutoffFrequency => this[GeneratorType.ModulationLfoToFilterCutoffFrequency];
int ModulationEnvelopeToFilterCutoffFrequency => this[GeneratorType.ModulationEnvelopeToFilterCutoffFrequency];
float ModulationLfoToVolume => 0.1F * this[GeneratorType.ModulationLfoToVolume];
float ChorusEffectsSend => 0.1F * this[GeneratorType.ChorusEffectsSend];
float ReverbEffectsSend => 0.1F * this[GeneratorType.ReverbEffectsSend];
float Pan => 0.1F * this[GeneratorType.Pan];
float DelayModulationLfo => SoundFontMath.TimecentsToSeconds(this[GeneratorType.DelayModulationLfo]);
float FrequencyModulationLfo => SoundFontMath.CentsToHertz(this[GeneratorType.FrequencyModulationLfo]);
float DelayVibratoLfo => SoundFontMath.TimecentsToSeconds(this[GeneratorType.DelayVibratoLfo]);
float FrequencyVibratoLfo => SoundFontMath.CentsToHertz(this[GeneratorType.FrequencyVibratoLfo]);
float DelayModulationEnvelope => SoundFontMath.TimecentsToSeconds(this[GeneratorType.DelayModulationEnvelope]);
float AttackModulationEnvelope => SoundFontMath.TimecentsToSeconds(this[GeneratorType.AttackModulationEnvelope]);
float HoldModulationEnvelope => SoundFontMath.TimecentsToSeconds(this[GeneratorType.HoldModulationEnvelope]);
float DecayModulationEnvelope => SoundFontMath.TimecentsToSeconds(this[GeneratorType.DecayModulationEnvelope]);
float SustainModulationEnvelope => 0.1F * this[GeneratorType.SustainModulationEnvelope];
float ReleaseModulationEnvelope => SoundFontMath.TimecentsToSeconds(this[GeneratorType.ReleaseModulationEnvelope]);
int KeyNumberToModulationEnvelopeHold => this[GeneratorType.KeyNumberToModulationEnvelopeHold];
int KeyNumberToModulationEnvelopeDecay => this[GeneratorType.KeyNumberToModulationEnvelopeDecay];
float DelayVolumeEnvelope => SoundFontMath.TimecentsToSeconds(this[GeneratorType.DelayVolumeEnvelope]);
float AttackVolumeEnvelope => SoundFontMath.TimecentsToSeconds(this[GeneratorType.AttackVolumeEnvelope]);
float HoldVolumeEnvelope => SoundFontMath.TimecentsToSeconds(this[GeneratorType.HoldVolumeEnvelope]);
float DecayVolumeEnvelope => SoundFontMath.TimecentsToSeconds(this[GeneratorType.DecayVolumeEnvelope]);
float SustainVolumeEnvelope => 0.1F * this[GeneratorType.SustainVolumeEnvelope];
float ReleaseVolumeEnvelope => SoundFontMath.TimecentsToSeconds(this[GeneratorType.ReleaseVolumeEnvelope]);
int KeyNumberToVolumeEnvelopeHold => this[GeneratorType.KeyNumberToVolumeEnvelopeHold];
int KeyNumberToVolumeEnvelopeDecay => this[GeneratorType.KeyNumberToVolumeEnvelopeDecay];
int KeyRangeStart => this[GeneratorType.KeyRange] & 0xFF;
int KeyRangeEnd => (this[GeneratorType.KeyRange] >> 8) & 0xFF;
int VelocityRangeStart => this[GeneratorType.VelocityRange] & 0xFF;
int VelocityRangeEnd => (this[GeneratorType.VelocityRange] >> 8) & 0xFF;
float InitialAttenuation => 0.1F * this[GeneratorType.InitialAttenuation];
int CoarseTune => this[GeneratorType.CoarseTune];
int FineTune => this[GeneratorType.FineTune] + sample.PitchCorrection;
LoopMode SampleModes => this[GeneratorType.SampleModes] != 2 ? (LoopMode)this[GeneratorType.SampleModes] : LoopMode.NoLoop;
int ScaleTuning => this[GeneratorType.ScaleTuning];
int ExclusiveClass => this[GeneratorType.ExclusiveClass];
int RootKey => this[GeneratorType.OverridingRootKey] != -1 ? this[GeneratorType.OverridingRootKey] : sample.OriginalPitch;
